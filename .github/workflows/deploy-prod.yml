name: Deploy Production (Manual)

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "GHCR image tag to deploy (e.g. main or sha-<gitsha>)"
        required: true
        default: "main"
      deploy_path:
        description: "Remote directory containing .env and compose deployment files"
        required: true
        default: "/opt/ai-coding-tutor"
      reset_mode:
        description: "Data reset mode (destructive options require confirmation)"
        required: true
        type: choice
        default: "none"
        options:
          - none
          - all_volumes
      reset_confirm:
        description: "Required only for reset_mode=all_volumes: type RESET_ALL_VOLUMES"
        required: false
        default: ""

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase image names
        id: vars
        shell: bash
        run: |
          owner_lc="$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')"
          repo_lc="$(echo "${GITHUB_REPOSITORY#*/}" | tr '[:upper:]' '[:lower:]')"
          echo "owner_lc=$owner_lc" >> "$GITHUB_OUTPUT"
          echo "repo_lc=$repo_lc" >> "$GITHUB_OUTPUT"

      - name: Ensure remote deploy directory exists
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || '22' }}
          script: |
            set -eu
            mkdir -p "${{ inputs.deploy_path }}"

      - name: Upload compose file
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || '22' }}
          source: "docker-compose.prod.yml"
          target: "${{ inputs.deploy_path }}"
          overwrite: true

      - name: Deploy selected image tag
        uses: appleboy/ssh-action@v1.2.0
        env:
          DEPLOY_PATH: ${{ inputs.deploy_path }}
          IMAGE_TAG: ${{ inputs.image_tag }}
          RESET_MODE: ${{ inputs.reset_mode }}
          RESET_CONFIRM: ${{ inputs.reset_confirm }}
          GHCR_OWNER: ${{ steps.vars.outputs.owner_lc }}
          GHCR_IMAGE_PREFIX: ${{ steps.vars.outputs.repo_lc }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || '22' }}
          envs: DEPLOY_PATH,IMAGE_TAG,RESET_MODE,RESET_CONFIRM,GHCR_OWNER,GHCR_IMAGE_PREFIX,GHCR_USERNAME,GHCR_TOKEN
          script: |
            set -euo pipefail
            cd "$DEPLOY_PATH"

            if [ ! -f .env ]; then
              echo "Missing $DEPLOY_PATH/.env (use .github/workflows/templates/env.prod.example as your template)"
              exit 1
            fi

            get_env_value() {
              __env_key="$1"
              __env_line="$(grep -E "^${__env_key}=" .env | tail -n 1 || true)"
              if [ -z "$__env_line" ]; then
                return 1
              fi
              __env_value="${__env_line#*=}"
              __env_value="${__env_value%$'\r'}"
              case "$__env_value" in
                \"*\")
                  __env_value="${__env_value#\"}"
                  __env_value="${__env_value%\"}"
                  ;;
                \'*\')
                  __env_value="${__env_value#\'}"
                  __env_value="${__env_value%\'}"
                  ;;
              esac
              printf '%s' "$__env_value"
            }

            trim_env_value() {
              printf '%s' "$1" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//'
            }

            GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH="$(get_env_value GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH || true)"
            GOOGLE_APPLICATION_CREDENTIALS_PATH_IN_CONTAINER="$(get_env_value GOOGLE_APPLICATION_CREDENTIALS || true)"
            SERVER_NAME_VALUE="$(get_env_value SERVER_NAME || true)"
            TLS_CERT_PATH_VALUE="$(get_env_value TLS_CERT_PATH || true)"
            TLS_KEY_PATH_VALUE="$(get_env_value TLS_KEY_PATH || true)"
            CERTBOT_EMAIL_VALUE="$(get_env_value CERTBOT_EMAIL || true)"
            ADMIN_EMAIL_VALUE="$(get_env_value ADMIN_EMAIL || true)"

            if [ -z "${CERTBOT_EMAIL_VALUE:-}" ] && [ -n "${ADMIN_EMAIL_VALUE:-}" ]; then
              CERTBOT_EMAIL_VALUE="${ADMIN_EMAIL_VALUE%%,*}"
            fi
            CERTBOT_EMAIL_VALUE="$(trim_env_value "${CERTBOT_EMAIL_VALUE:-}")"

            ensure_tls_certificate() {
              if [ -z "${SERVER_NAME_VALUE:-}" ] || [ -z "${TLS_CERT_PATH_VALUE:-}" ] || [ -z "${TLS_KEY_PATH_VALUE:-}" ]; then
                echo "Missing SERVER_NAME/TLS_CERT_PATH/TLS_KEY_PATH in $DEPLOY_PATH/.env"
                echo "Cannot verify or issue TLS certificates without these values."
                exit 1
              fi

              if docker compose -f docker-compose.prod.yml --profile ops run --rm --no-deps --entrypoint sh certbot -lc \
                "test -f \"$TLS_CERT_PATH_VALUE\" && test -f \"$TLS_KEY_PATH_VALUE\""; then
                echo "TLS certificate files already exist: $TLS_CERT_PATH_VALUE and $TLS_KEY_PATH_VALUE"
                return 0
              fi

              if [ -z "${CERTBOT_EMAIL_VALUE:-}" ]; then
                echo "TLS certificate files are missing and no Certbot contact email is configured."
                echo "Set CERTBOT_EMAIL (preferred) or ADMIN_EMAIL in $DEPLOY_PATH/.env."
                exit 1
              fi

              echo "TLS certificate files are missing. Issuing a new Let's Encrypt certificate for ${SERVER_NAME_VALUE}..."
              docker compose -f docker-compose.prod.yml stop frontend >/dev/null 2>&1 || true
              docker compose -f docker-compose.prod.yml --profile ops run --rm --no-deps -p 80:80 --entrypoint certbot certbot \
                certonly --standalone --non-interactive --agree-tos --no-eff-email \
                -d "${SERVER_NAME_VALUE}" -m "${CERTBOT_EMAIL_VALUE}"

              if ! docker compose -f docker-compose.prod.yml --profile ops run --rm --no-deps --entrypoint sh certbot -lc \
                "test -f \"$TLS_CERT_PATH_VALUE\" && test -f \"$TLS_KEY_PATH_VALUE\""; then
                echo "Certbot finished, but TLS certificate files are still missing."
                echo "Expected files: $TLS_CERT_PATH_VALUE and $TLS_KEY_PATH_VALUE"
                exit 1
              fi

              echo "TLS certificate issued successfully for ${SERVER_NAME_VALUE}"
            }

            if [ -z "${GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH:-}" ]; then
              echo "Missing GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH in $DEPLOY_PATH/.env"
              echo "Use .github/workflows/templates/env.prod.example as the template."
              exit 1
            fi

            case "$GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH" in
              /*)
                ;;
              *)
                echo "GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH must be an absolute server path in production .env."
                echo "Current value: $GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH"
                echo "Example: /opt/ai-coding-tutor/secrets/ai-coding-tutor-service-account.json"
                exit 1
                ;;
            esac

            if [ -z "${GOOGLE_APPLICATION_CREDENTIALS_PATH_IN_CONTAINER:-}" ]; then
              echo "Missing GOOGLE_APPLICATION_CREDENTIALS in $DEPLOY_PATH/.env"
              echo "Use .github/workflows/templates/env.prod.example as the template."
              exit 1
            fi

            if [ ! -f "$GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH" ]; then
              echo "Google service account JSON file not found: $GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH"
              echo "Place the JSON file on the server first and keep the path in .env in sync."
              exit 1
            fi

            if [ ! -r "$GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH" ]; then
              echo "Google service account JSON file is not readable: $GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH"
              exit 1
            fi

            echo "Verified Google service account JSON file: $GOOGLE_APPLICATION_CREDENTIALS_HOST_PATH"
            echo "Container mount path: $GOOGLE_APPLICATION_CREDENTIALS_PATH_IN_CONTAINER"

            if [ -n "${GHCR_TOKEN:-}" ] && [ -n "${GHCR_USERNAME:-}" ]; then
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
            fi

            export GHCR_OWNER
            export GHCR_IMAGE_PREFIX
            export IMAGE_TAG

            docker compose -f docker-compose.prod.yml config >/dev/null

            case "${RESET_MODE:-none}" in
              none)
                ;;
              all_volumes)
                echo "WARNING: reset_mode=all_volumes will delete all Docker Compose volumes for this stack (PostgreSQL, uploads, notebooks, certbot)."
                echo "WARNING: This is destructive. Take a backup before continuing."
                if [ "${RESET_CONFIRM:-}" != "RESET_ALL_VOLUMES" ]; then
                  echo "Refusing destructive reset because reset_confirm did not match RESET_ALL_VOLUMES."
                  exit 1
                fi
                docker compose -f docker-compose.prod.yml down -v
                ;;
              *)
                echo "Unsupported reset_mode: ${RESET_MODE}"
                exit 1
                ;;
            esac

            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml up -d db backend
            ensure_tls_certificate
            docker compose -f docker-compose.prod.yml up -d frontend
            docker compose -f docker-compose.prod.yml --profile ops up -d certbot
            docker compose -f docker-compose.prod.yml ps

            if ! docker compose -f docker-compose.prod.yml exec -T backend python - <<'PY'
            import json
            import sys
            import urllib.request
            def fetch(url: str):
                with urllib.request.urlopen(url, timeout=15) as response:
                    return json.loads(response.read().decode("utf-8"))

            health = fetch("http://127.0.0.1:8000/health")
            print({"health": health})

            ai_health = fetch("http://127.0.0.1:8000/api/health/ai?force=true")
            print({"ai_health": ai_health})

            if not ai_health.get("google"):
                sys.exit("Vertex Gemini health check failed (google=false)")
            PY
            then
              echo "Post-deploy health check failed. Printing recent backend logs..."
              docker compose -f docker-compose.prod.yml logs --tail=200 backend || true
              exit 1
            fi
